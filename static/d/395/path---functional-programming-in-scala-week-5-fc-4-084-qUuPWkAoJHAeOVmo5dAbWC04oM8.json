{"data":{"site":{"siteMetadata":{"title":"bono's blog","author":"bono"}},"markdownRemark":{"id":"6dbb6b94-3ef5-5d30-9a93-6202c74f2eec","excerpt":"5.1 More Functions on Lists 이번 챕터에서는 스칼라 List 의 다른 메서드 들을 알아본다.\nxs 는 list 의 object 를 뜻한다. Sublists and element access xs.length xs 의 길이 xs…","html":"<h2>5.1 More Functions on Lists</h2>\n<p>이번 챕터에서는 스칼라 List 의 다른 메서드 들을 알아본다.\nxs 는 list 의 object 를 뜻한다.</p>\n<h3>Sublists and element access</h3>\n<ul>\n<li>xs.length xs 의 길이</li>\n<li>xs.last xs 의 마지막 item return, xs 가 비어있으면 exception 발생</li>\n<li>xs.init 마지막 item 을 제외한 list reutnr, xs 가 비어있으면 exception 발생</li>\n<li>xs take n 처음부터 n 개의 element 의 list 리턴, n 이 xs 의 length 보다 크면 n 개만 리턴</li>\n<li>xs drop n n 개를 제외한 나머지 리스트 리턴</li>\n<li>xs(n) n 번째 item 리턴</li>\n</ul>\n<h3>Creating new lists</h3>\n<ul>\n<li>xs ++ ys 두 list 더하기, :::와 같은 기능을 함</li>\n<li>xs.reverse 역순의 리스트 생성</li>\n<li>xs updated (n, x) n 번째 item 만 x 로 바뀐 list 생성</li>\n</ul>\n<h3>Finding elements</h3>\n<ul>\n<li>xs indexOf x x 와 같은 첫번째 element 의 index 값 리턴, 없으면 -1</li>\n<li>xs contains x indexOf x >= 0 과 같음</li>\n</ul>\n<p>last 가 과연 필요한지 모르겠지만(tail 을 recursive 하게 반복하면 찾을 수 있음), 유용하게 쓰일 수 있다면 last 의 복잡도는 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def last[T](xs: List[T]): T = xs match {\n  case List() =&gt; throw new Error(&quot;last of empty list&quot;)\n  case List(x) =&gt; x\n  case y :: ys =&gt; lsat(ys)\n}</code></pre></div>\n<p>위와 같이 list 의 길이와 같으므로, 복잡도는 O(n)이 되겠다.\ninit 메서드는 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def init[T](xs: List[T]): List[T] = xs match {\n  case List() =&gt; throw new Error(&quot;init of empty list&quot;)\n  case List(x) =&gt; List()\n  case y :: ys =&gt; y :: init(ys)\n}</code></pre></div>\n<p>마찬가지로 O(n)\n그다음은 concat(Same as :::)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def concat[T](xs: List[T], ys: List[T]) = xs match {\n  case List() =&gt; ys\n  case z :: zs =&gt; z :: concat(zs, ys)\n}</code></pre></div>\n<p>복잡도는 |xs|, 즉 xs 의 길이가 된다.\n다음은 reverse</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def reverse[T](xs: List[T]): List[T] = xs match {\n  case List() =&gt; xs\n  case y :: ys =&gt; reverse(ys) ++ List(y)\n}</code></pre></div>\n<p>reverse(ys) :: y 가 아니라 reverse(ys) ++ List(y)인 이유는 ::의 마지막엔 Nil 이 와야하니깐 y 가 Nil 이 아니기 때문이 아닐까 생각한다.\n복잡도는 각 요소마다 concatenating 을 해주고 list 의 length 만큼 reverse 를 해야하므로 O(n2)이 되겠다. reverse 는 다소 실망스러운 성능을 보여주는데, 앞으로 더 개선해보도록 하겠다.</p>\n<p>마지막으로 removeAt</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def removeAt[T](n: Int, xs: List[T]) = (xs take n) ::: (xs drop n+1)</code></pre></div>\n<h2>5.2 Paires and Tuples</h2>\n<p>앞서 살펴보앗던 insertion sort 보다 더 개선된 merge sort 알고리즘에 대해서 살펴보자. 기본적인 개념은 zero or one element 리스트는 이미 sorted 하다는 것.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def msort(xs: List[Int]): List[Int] = {\n  val n = xs.length/2\n  if (n == 0) xs\n  else {\n    // merge 메서드는 앞으로 더 개선해 나갈 예정임\n    def merge(xs: List[Int], ys: List[Int]) =\n      xs mathch {\n        case Nil =&gt; ys\n        case x :: xs1 =&gt;\n          ys match {\n            case Nil =&gt; xs\n            case y :: ys1 =&gt;\n              if (x &lt; y) x :: merge(xs1, ys)\n              else y :: merge(xs, ys1)\n          }\n      }\n\n    val (fst, snd) = xs splitAt n\n    merge(msort(fst), msort(snd))\n  }\n}</code></pre></div>\n<p>밑에서 나오는 splitAt 함수는 index n 을 기준으로 리스트를 두개로 쪼개서 리턴한다. 여기서 리턴된 val 의 모양을 보자. fst 와 snd 두개의 타입으로 묶여져 있다. 이를 Pair 라고 한다. 예를 들면</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">val pair = (&quot;answer&quot;, 42) &gt; pair: (String, Int) = (answer,42)\n\nval (label, value) = pare &gt; label: String = answer | value : Int = 42</code></pre></div>\n<p>위와 같이 타입으로도 쓰일 수 있고, 패턴으로도 사용될 수 있다. 이때 2 개 이상의 요소를 가지면 Tuples 라 한다. Tuples 는 다양하게 사용될 수 있는데, parameterized type 으로 사용될 경우, function applictaion 으로 사용될 경우, constructor 패턴으로 사용될 경우 각각</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">scala.Tuplen[T1, ..., Tn]\nscala.Tuplen(e1, ..., en)\nscala.Tuplen(p1, ..., pn)</code></pre></div>\n<p>과 같이 사용할 수 있다. (여기서 Tuplen 의 n 은 파라미터 개수 ex. Tuple2)\n튜플의 각 element 는 _1, _2 와 같이 접근할 수 있다.\n이제 merge 메소드를 개선해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {\n  case (Nil, ys) =&gt; ys\n  case (xs, Nil) =&gt; xs\n  case (x :: xs1, y :: ys1) =&gt;\n    if (x &lt; y) x :: merge(xs1, ys)\n    else y :: merge(xs, ys1)\n}</code></pre></div>\n<p>훨씬 깔끔해졌다.</p>\n<h2>5.3 Implicit Parameters</h2>\n<p>이전 장에서 보았던 msort 는 List[Int] 타입으로 지정되어 있는데 parameterize 를 통해서 Int 말고도 다른 타입이 들어올 수 있도록 임의의 타입 T 로 변경해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object mergesort {\n  def msort[T](xs: List[T]): List[T] = {\n    val n = xs.length/2\n    if (n == 0) xs\n    else {\n      def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {\n        case (Nil, ys) =&gt; ys\n        case (xs, Nil) =&gt; xs\n        case (x :: xs1, y :: ys1) =&gt;\n          if (x &lt; y) x :: merge(xs1, ys)\n          else y :: merge(xs, ys1)\n      }\n\n      val (fst, snd) = xs splitAt n\n      merge(msort(fst), msort(snd))\n    }\n  }\n\n  val nums = List(2, -4, 5, 7, 1)\n  msort(nums)\n}</code></pre></div>\n<p>x &#x3C; y 부분에서 에러가 발생한다. 왜냐하면 comparison ’&#x3C;‘가 임의의 타입 T 에 정의되어 있지 않기 때문이란다…\n그래서 우리는 comparison 함수가 필요하다. 이 때 가장 유연한 방법은 msort 함수에 comparison operation 을 추가적인 파라미터로 붙이는 것이다. 아래처럼</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def msort[T](xs: List[T])(lt: (T, T) =&gt; Boolean) = {\n  ...\n  merge(msort(fst)(lt), msort(snd)(lt))\n}</code></pre></div>\n<p>그래서 원래 mergesort 에 적용하면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object mergesort {\n  def msort[T](xs: List[T])(lt: (T, T) =&gt; Boolean): List[T] = {\n    val n = xs.length/2\n    if (n == 0) xs\n    else {\n      def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {\n        case (Nil, ys) =&gt; ys\n        case (xs, Nil) =&gt; xs\n        case (x :: xs1, y :: ys1) =&gt;\n          if (lt(x, y)) x :: merge(xs1, ys)\n          else y :: merge(xs, ys1)\n      }\n\n      val (fst, snd) = xs splitAt n\n      merge(msort(fst)(lt), msort(snd)(lt))\n    }\n  }\n\n  val nums = List(2, -4, 5, 7, 1)\n  msort(nums)((x, y) =&gt; x &lt; y)\n\n  val fruits = List(&quot;apple&quot;, &quot;pineapple&quot;, &quot;banana&quot;, &quot;orange&quot;)\n  msort(fruits)((x, y) =&gt; x.compareTo(y) &lt; 0)\n}</code></pre></div>\n<p>이제 Int 타입 뿐만 아니라 String 과 같은 다른 타입도 정렬이 가능해졌다. 이 때 lt 에 들어오는 함수 파라미터에 타입 붙이는 걸 생략해도 되는데, 컴파일러가 앞에 있는 리스트의 타입을 보고 유추할 수 있기 때문이란다. 즉 파라미터 셋의 마지막에 function value 가 들어오게 되면, 컴파일러가 타입 체크를 미뤄버린다.</p>\n<h3>scala.math.Ordering[T]</h3>\n<p>사실 ordering 을 위한 스탠다드 라이브러리 클래스가 있다.</p>\n<blockquote>\n<p>scala.math.Ordering[T]</p>\n</blockquote>\n<p>그래서 lt 명령어를 parameterizing 하는 대신 Orderging 클래스로 parameterize 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def msort[T](xs: List[T])(ord: Ordering) =\n\n  def merge(xs: List[T], ys: List[T]) =\n    ... if (ord.lt(x, y)) ...\n\n  ... merge(msort(fst)(ord), msort(snd)(ord)) ...</code></pre></div>\n<h3>implicit</h3>\n<p>대체로 완성된 느낌이 나지만, Ordering 함수가 처음 콜 될때부터 계속 전달되는게 좀 비효율적으로 보인다. 그래서 여기에다가 또하나를 추가해보자.\nord 파라미터에 implicit(절대적인이란 뜻) 키워드를 앞에 붙여보자. 그러면, 함수를 실제로 호출하는 부분에서 실제 파라미터를 넣어줄 필요가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def msort[T](xs: List[T])(implicit ord: Ordering) =\n\n  def merge(xs: List[T], ys: List[T]) =\n    ... if (ord.lt(x, y)) ...\n\n  ... merge(msort(fst), msort(snd)) ...\n\nval nums = List(2, -4, 5, 7, 1)\nmsort(nums)</code></pre></div>\n<p>더 간결해졌다.</p>\n<h3>Rules for Implicit Parameters</h3>\n<p>타입이 T 인 implicit 파라미터가 있을때, 컴파일러는</p>\n<blockquote>\n<p>(1) implicit 이 쓰인 파라미터에 (2) T 와 호환되는 타입을 가지고 (3) function call 에서 보이거나 T 와 관련된 companion 오브젝트(클래스와 객체 이름이 같은 오브젝트)에서\nsingle implicit definition 을 찾는다. 즉, Ordering[Int]가 함수 call 의 파라미터로 존재하지 않지만, implicit 으로 처리되어 어딘가에 존재하게 된다.</p>\n</blockquote>\n<h2>5.4 Higher-Order List Functions</h2>\n<p>위에서 보았던 예제들은 종종 비슷한 구조를 보여준다. 요약해보면</p>\n<ul>\n<li>리스트의 각 element 를 변경하는 것</li>\n<li>어떤 조건을 만족하는 모든 element 의 리스트를 구하는 것</li>\n<li>연산자를 사용하여 element 들을 결합하는 것</li>\n</ul>\n<p>함수형 언어는 higer-order functinos 패턴을 이용하는 generic function 을 만들 수 있다.</p>\n<p>첫번째 예제는 각 요소를 multiply 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def scaleList(xs: List[Double], factor: Double): List[Double] = xs match {\n  case Nil =&gt; xs\n  case y :: ys =&gt; y * factor :: scaleList(ys, factor)\n}</code></pre></div>\n<h3>Map</h3>\n<p>위 예제는 list 의 map 메서드를 이용하여 만들 수 있다.\nmap 메서드의 구조를 살펴보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">abstract class List[T] { ...\n  def map[U](f: T =&gt; U): List[U] = this match {\n    case Nil =&gt; this\n    case x :: xs =&gt; f(x) :: xs.map(f)\n  }\n}</code></pre></div>\n<p>파라미터로 들어온 함수 f 가 각 element 에 적용되어서 새로운 리스트를 만들어 내는 함수가 바로 map 이다. map 메서드를 이용하면 훨씬 간단하게 작성할 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def scaleList(xs: List[Double], factor: Double) =\n  xs.map(x =&gt; x * factor)</code></pre></div>\n<p>또하나의 예제를 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def squareList(xs: List[Int]): List[Int] = xs match {\n  case Nil =&gt; Nil\n  case y :: ys =&gt; y * y :: squareList(ys)\n}\n\ndef squareList(xs: List[Int]): List[Int] =\n  xs map (y =&gt; y * y)</code></pre></div>\n<h3>Filtering</h3>\n<p>필터링은 어떤 조건에 맞는 element 를 모아 새로운 리스트를 만들어 내는 메서드이다.\n0 보다 큰수만 필터링 하는 다음의 함수를 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def posElems(xs: List[Int]): List[Int] = xs match {\n  case Nil =&gt; xs\n  case y :: ys =&gt; if (y &gt; 0) y :: posElems(ys) else posElems(ys)\n}</code></pre></div>\n<p>필터를 이용하면 간단하게 해결할 수 있다. 우선은 filter 메서드가 어떻게 생겼는지부터 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">abstract class List[T] {\n  ...\n  def filter(p: T =&gt; Boolean): List[T] = this match {\n    case Nil =&gt; this\n    case x :: xs =&gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)\n  }\n}</code></pre></div>\n<p>필터는 특정조건함수(p)가 true 이면 :: 연산자를 이용하여 리스트에 붙이고 false 이면 제외하는 방식으로 새로운 리스트를 만들어간다.\n그럼 위에서 보았던 posElems 를 filter 를 이용해 재구성해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def posElems(xs: List[Int]): List[Int] =\n  xs filter(x =&gt; x &gt; 0)</code></pre></div>\n<p>그외에 유용한 메서드 목록은 아래와 같다.</p>\n<ul>\n<li>xs filterNot p xs filter (x => !p(x))와 같다.</li>\n<li>xs partition p (xs filter p, xs filterNot) 튜플</li>\n<li>xs takeWhile p p 를 만족하는 요소들의 가장 긴 리스트</li>\n<li>xs dropWhile p p 를 만족하는 요소들의 나머지</li>\n<li>xs span p (xs takeWhile p, xs dropWhile p) 튜플</li>\n</ul>\n<p>예를 들어보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">scala&gt; val nums = List(2, -4, 5, 7, 1)\nnums: List[Int] = List(2, -4, 5, 7, 1)\n\nscala&gt; nums filter (x =&gt; x &gt; 0)\nres0: List[Int] = List(2, 5, 7, 1)\n\nscala&gt; nums filterNot (x =&gt; x &gt; 0)\nres1: List[Int] = List(-4)\n\nscala&gt; nums partition (x =&gt; x &gt; 0)\nres2: (List[Int], List[Int]) = (List(2, 5, 7, 1),List(-4))\n\nscala&gt; nums takeWhile (x =&gt; x &gt; 0)\nres3: List[Int] = List(2)\n\nscala&gt; nums dropWhile (x =&gt; x &gt; 0)\nres4: List[Int] = List(-4, 5, 7, 1)\n\nscala&gt; nums span (x =&gt; x &gt; 0)\nres5: (List[Int], List[Int]) = (List(2),List(-4, 5, 7, 1))</code></pre></div>\n<h2>5.5 Reductino of Lists</h2>\n<p>5.4 절에 이어 higr-order Function 패턴을 이용한 List 메서드에 대해서 계속 알아보도록 하자. 5.4 에서 보았던 세가지 패턴 중에 마지막인 element 를 결합하는 방법들에 대한 내용들이 되겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sum(List(x1, ..., xn))      = 0 + x1 + ... + xn\nproduct(List(x1, ..., xn))  = 1 * x1 * ... * xn</code></pre></div>\n<h3>ReduceLeft</h3>\n<p>각 요소를 더하거나 곱하는 sum 과 product 메서드가 있다. 이를 ReduceLeft 메서드를 이용하여 구현해보도록하자. ReduceLeft 메서드는 아래와 같은 구조를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">List(x1, ..., xn) reduceLeft op = (...(x1 op x2) op ... ) op xn\n\n// 위의 구조를 이용하면 sum과 product는 아래와 같이 구현가능하다.\ndef sum(xs: List[Int]) = (0 :: xs) reduceLeft ((x, y) =&gt; x + y) // or (_ + _)\ndef product(xs: List[Int]) = (1 :: xs) reduceLeft ((x, y) =&gt; x * y) // or (_ * _)</code></pre></div>\n<h3>FoldLeft</h3>\n<p>foldLeft 함수는 reduceLeft 함수에 비해 좀더 일반적인 형태이다. foldLeft 가 reduceLeft 와 비슷하지만, foldLeft 는 하나의 accumulator(z)를 가진다.\n구조는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(List(x1, ..., xn) foldLeft z)(op) = (...(z op x1) op ...) op xn</code></pre></div>\n<p>foldLeft 로 sum 과 product 를 구현해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def sum(xs: List[Int]) = (xs foldLeft 0) (_ + _)\ndef product(xs: List[Int]) = (xs foldLeft 1) (_ * _)</code></pre></div>\n<p>foldLeft 와 reduceLeft 는 List class 에서 다음과 같이 구현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">abstract class List[T] { ...\n  def reduceLeft(op: (T, T) =&gt; T): T = this match {\n    case Nil =&gt; throw new Error(&quot;Nil.reduceLeft&quot;)\n    case x :: xs =&gt; (xs foldLeft x)(op)\n  }\n  def foldLeft[U](z: U)(op: (U, T) =&gt; U): U = this match {\n    case Nil =&gt; z\n    case x :: xs =&gt; (xs foldLeft op(z, x))(op)\n  }\n}</code></pre></div>\n<p>reduceLeft 도 내부적으로는 foldLeft 메서드를 이용한다.\n그리고 reduceRight 와 foldRight 도 위의 두 메서드와 비슷한 구조로 동작한다. 대신 좌측이 아닌 우측(뒤)부터 reduce 한다.</p>\n<h3>Difference between FoldLeft and FoldRight</h3>\n<p>foldLeft 와 foldRight 는 무엇이 다를까? 기본적으로 sum 을 가지고 생각했을때, 왼쪽부터 더하는 것이나 오른쪽부터 더하는 것이나 결과는 동일하다. 하지만 어떤 경우에는 둘 중 하나만 적절할 때도 있다. 아래의 예제를 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def concat[T](xs: List[T], ys: List[T]): List[T] = (xs foldRight ys) (_ :: _)</code></pre></div>\n<p>위의 함수에서 foldRight 를 foldLeft 로 변경하면, 타입에러가 발생한다.\n1 :: List(2)는 가능하지만 List(1) :: 2 는 불가능한 연산이기 때문이다.</p>\n<h2>5.6 Reasoning About Concat</h2>\n<p>이번 챕터에서는 어떤 연산자(or 함수)가 정확히 참임을 증명할 수 있는지에 대해 알아보도록 한다.\n일반적으로 natural induction(자연 귀납?)에 의해 증명하는 방법의 예는 다음과 같다.</p>\n<ul>\n<li>P(n)이 모든 n >= b 에대해서</li>\n<li>P(b)가 참이다. (base case)</li>\n<li>이때, 모든 n >= b 에 대해서 P(n)이 참이면, P(n + 1)도 참이다.</li>\n</ul>\n<h3>Referential Transparency (참조 투명성)</h3>\n<p>순수한 함수형 프로그램에서는 사이드 이펙트가 없기 때문에, reduction steps 가 어떤 부분에 대해서도 동일하게 적용된다. 이를 Referential Transparency(참조 투명성)이라 한다.</p>\n<p>structural induction 은 natural induction 과 비슷하다.\nstructural induction 은 다음과 같이 동작한다.</p>\n<ul>\n<li>P(xs)이 모든 리스트 xs 에 대해서</li>\n<li>P(Nil)이 hold 된다면</li>\n<li>리스트 xs 와 어떤 element x 에 대해서 P(xs)가 hold 되다면, P(x :: xs) 또한 hold 된다.</li>\n</ul>\n<p>이제 concat 함수를 다시 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def concat[T](xs: List[T], ys: List[T]) = xs match {\n  case List() =&gt; ys\n  case x :: xs1 =&gt; x :: concat(xs1, ys)\n}</code></pre></div>\n<p>그리고 다음의 수식을 structural induction 으로 증명해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)\n// ++(concat) 연산자의 두가지 정리를 참고한다\n// Nil ++ ys = ys\n// (x :: xs1) ++ ys = x :: (xs1 ++ ys)</code></pre></div>\n<p>우선 xs 에 Nil 이 들어갈 때인 P(Nil)을 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// left\n(Nil ++ ys) ++ zs\n= ys ++ zs      // by 1st clause of ++\n\n// right\nNil ++ (ys ++ zs)\n= ys ++ zs      // by 1st clause of ++</code></pre></div>\n<p>다음은 xs 대신에 induction step 인 ‘x :: xs’를 넣어보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// left\n((x :: xs) ++ ys) + zs\n= (x :: (xs ++ ys)) ++ zs      // by 2st clause of ++\n= x :: ((xs ++ ys) ++ zs)      // by 2st clause of ++\n= x :: (xs ++ (ys ++ zs))    // by induction hypothesis\n// right\n(x :: xs) ++ (ys ++ zs)\n= x :: (xs ++ (ys ++ zs))    // by 2st clause of ++</code></pre></div>\n<p>좌변과 우변이 같으므로 함수 P 는 증명됨</p>\n<h2>5.7 A Larger Equational Proof on Lists</h2>\n<p>좀더 까다로운 function 인 reverse 에 대해서 알아보자\n다음의 두가지 amenable 한 사실을 가지고 그 아래의 식을 증명해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(1) Nil.reverse = Nil               // 1st clause\n(2) (x :: xs).reverse = xs.reverse ++ List(x)   // 2nd clause\n\n// 다음을 증명\nxs.reverse.reverse = xs</code></pre></div>\n<p>base case 는 단순하다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Nil.reverse.reverse\n= Nil.reverse\n= Nil</code></pre></div>\n<p>이번엔 reduction step 이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// left\n(x :: xs).reverse.reverse\n= (xs.reverse ++ List(x)).reverse     // by 2nd clause of reverse\n\n// right\nx :: xs\n= x :: xs.reverse.reverse       // by induction hypothesis (가설에 의해)</code></pre></div>\n<p>두 개를 합쳐보면,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(xs.reverse ++ List(x)).reverse = x :: xs.reverse.reverse</code></pre></div>\n<p>직접적으로 induction 이 불가하므로, 동일한 연산을 일반화 시켜보자\n여기서는 xs.reverse 를 ys 로 치환하도록 하자. 그럼 수식이 아래와 같이 바뀐다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(ys ++ List(x)).reverse = x :: ys.reverse</code></pre></div>\n<p>그럼 이제 두번째 induction 인 ys 를 증명하면 동일함을 입증할 수 있겠다.\n우선 base case 부터 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// left\n(Nil ++ List(x)).reverse\n= List(x).reverse       // by 1st clause of ++\n= (x :: Nil).reverse    // by definition of List\n= Nil.reverse ++ List(x)\n= Nil ++ (x :: Nil)     // by 2nd clause of reverse\n= x :: Nil          // by 1st clause of ++\n= x :: Nil.reverse      // by 1st clause of reverse</code></pre></div>\n<p>결과는 우변의 ys 에 Nil 을 집어넣었을 때와 동일한 결과과 도출되었으므로 base case 를 증명되었다. 이제 reduction step 으로 가보자</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// left\n((y :: ys) ++ List(x)).reverse\n= (y :: (ys ++ List(x))).reverse    // by 2nd clause of ++\n= (ys ++ List(x)).reverse ++ List(y)  // by 2nd clause reverse\n= (x :: ys.reverse) ++ List(y)      // by the induction hypothesis\n= x :: (ys.reverse ++ List(y))      // by 1st clause of ++\n= x :: (y :: ys).reverse        // by 2nd clause of reverse\n\n// right\nx :: (y :: ys).reverse</code></pre></div>\n<p>좌변과 우변이 동일하므로 증명되었다.</p>\n<h3>Exercise</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(xs ++ ys) map f = (xs map f) ++ (ys map f)\n\nNil map f = Nil\n(x :: xs) map f = f(x) :: (xs map f)</code></pre></div>\n<p>base case..</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// left\n(Nil ++ ys) map f\n= ys map f\n\n// right\n(Nil map f) ++ (ys map f)\n= Nil ++ (ys map f)\n= ys map f</code></pre></div>\n<p>reduction step</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// left\n((x :: xs) ++ ys) map f\n= (x :: (xs ++ ys)) map f\n= f(x) :: ((xs ++ ys) map f)\n= f(x) :: ((xs map f) ++ (ys map f))\n\n// right\n((x :: xs) map f) ++ (ys map f)\n= (f(x) :: (xs map f)) ++ (ys map f)\n= f(x) :: ((xs map f) ++ (ys map f))</code></pre></div>\n<p>base case, reduction step 모두 좌변과 우변이 같으므로 같음이 증명되었다.</p>","frontmatter":{"title":"Functional Programming in Scala week 5","date":"July 26, 2016"}}},"pageContext":{"slug":"/functional-programming-in-scala-week5/","previous":{"fields":{"slug":"/django-extend-view-using-mixin/"},"frontmatter":{"title":"[django] Mixin을 이용한 View 확장하기"}},"next":{"fields":{"slug":"/functional-programming-in-scala-week6/"},"frontmatter":{"title":"Functional Programming in Scala week 6"}}}}