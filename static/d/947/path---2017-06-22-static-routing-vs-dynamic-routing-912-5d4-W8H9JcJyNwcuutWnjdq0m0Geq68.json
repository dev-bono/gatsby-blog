{"data":{"site":{"siteMetadata":{"title":"bono's blog","author":"bono"}},"markdownRemark":{"id":"e7cd9d00-54a5-5185-a89a-58edd85a12b9","excerpt":"react-router v4 가 릴리즈 되면서 라우팅 적용 방식이 바뀌었습니다.\n이전버전(v3)까지는 일반적으로 사용하는 정적 라우팅(Static Routing)이였다면, 동적 라우팅(Dynamic Routing…","html":"<p>react-router v4 가 릴리즈 되면서 라우팅 적용 방식이 바뀌었습니다.\n이전버전(v3)까지는 일반적으로 사용하는 정적 라우팅(Static Routing)이였다면, 동적 라우팅(Dynamic Routing)이 적용되었는데요.\n여기서 말하는 정적 라우팅이란 일반적으로 최상위 페이지에 라우팅 정보를 모두 기입해 두고, 특정 패스가 브라우저에 입력되었을 때 해당되는 컴포넌트를 그려주는 방식을 말합니다. 모든 라우팅 정보가 한곳에 위치하기 때문에 관리하기 쉽다는 장점이 있겠지만, 정적이라는 특징 때문에 확장성과 재사용성은 떨어질 수 있습니다. 반면에 동적 라우팅의 경우에는 라우팅 정보를 한곳에 모아둘 필요가 없습니다. 라우팅이 필요한 컴포넌트에 직접 붙여 사용할 수 있기 때문에 동적으로 컴포넌트를 구성하는데 더 효율적이라 할 수 있습니다.</p>\n<p>이외에도 몇가지 바뀐점이 꽤 있다보니 이전버전과 어떤 점이 달라졌나 비교해볼까 합니다.</p>\n<p><a href=\"https://reacttraining.com/react-router/\">공식 홈페이지 바로가기</a></p>\n<h2>설치</h2>\n<p>설치하는 모듈을 선택할 수 있는데요. 이전 버전까지는 <code class=\"language-text\">react-router</code> 하나만 사용 할 수 있었는데,\n이번에 버전업 되면서 몇가지 늘었습니다. react-router 는 코어 모듈이구요.\n이밖에도 <code class=\"language-text\">react-router-dom</code>, <code class=\"language-text\">react-router-native</code> 등이 추가되었습니다.\nreact-router-dom 은 react-router 모듈에 dom 이 바인딩 되어 있다고 보시면 됩니다. 즉, 웹 개발자들을 위한 모듈이죠.\n그리고 react-router-native 는 이름에서도 알 수 있듯이 react-native 를 개발할 때 사용하는 모듈입니다.\n저는 웹개발자이기 때문에 당연히 react-router-dom 을 사용하도록 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># v3\nyarn add react-router\nnpm install react-router\n\n# v4\nyarn add react-router-dom\nnpm install react-router-dom</code></pre></div>\n<h2>v3 VS v4</h2>\n<p>v3 와 v4 의 차이점을 간략히 비교해 보았습니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"left\">v3</th>\n<th align=\"left\">v4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">라우팅</td>\n<td align=\"left\">정적(static) 라우팅</td>\n<td align=\"left\">동적(dynamic) 라우팅</td>\n</tr>\n<tr>\n<td align=\"center\">Route 컴포넌트</td>\n<td align=\"left\">라우트 정보를 프로젝트 최상단에 모두 정의</td>\n<td align=\"left\">코드 어디에나 사용 가능</td>\n</tr>\n<tr>\n<td align=\"center\">계층구조</td>\n<td align=\"left\">라우트 정보를 계층구조로 표현</td>\n<td align=\"left\">계층구조 대신 렌더링 되는 컴포넌트에 직접 구현 (계층구조 표현 안됨)</td>\n</tr>\n<tr>\n<td align=\"center\">히스토리</td>\n<td align=\"left\">browserHistory 에 저장하여 Router 객체에 props 로 삽입</td>\n<td align=\"left\">BrowserRouter 객체에 내장</td>\n</tr>\n</tbody>\n</table>\n<h2>v3 의 라우팅 코드</h2>\n<p>프로젝트 구조를 자세히 설명하지는 않겠습니다.\n간단히 구조만 살펴볼 것이기 때문에 최소한의 파일만으로 구성하였습니다.</p>\n<p>react-router v3 는 정적 라우팅을 사용하기 때문에 미리 라우팅 정보를 탑 레벨에서 모두 정해두고 시작합니다.\nreact-router 는 계층구조로 설정할 수가 있는데, 최상위에 <code class=\"language-text\">Router</code> 컴포넌트를 만들고 <code class=\"language-text\">Route</code>(실제 패스에 따라 컴포넌트를 교체해주는 역할) 컴포넌트를 아래에 만듭니다. 그리고 또 그 아래에 <code class=\"language-text\">IndexRoute</code>가 있고 여러개의 <code class=\"language-text\">Route</code> 컴포넌트가 존재합니다.\n어떤 url 이 브라우저에 입력되면(또는 앵커 태그가 클릭되면), 각 라우터에 해당하는 컴포넌트가 렌더링 되는 구조입니다.</p>\n<p>예를 들어 <code class=\"language-text\">http://localhost:3000/second</code> url 이 브라우저에 입력되면 path 가 <code class=\"language-text\">/</code>인 라우트를 먼저 찾고 렌더링 합니다. 그리고 뒤에 해당되는 <code class=\"language-text\">second</code>를 찾아서 해당되는 컴포넌트를 렌더링 합니다.</p>\n<p>App.js 파일의 App 클래스를 보면, Header 컴포넌트 아래에 <code class=\"language-text\">{this.props.childern}</code>이 있는데, 이 부분이 바로 path 가 <code class=\"language-text\">/</code>인 라우트 아래의 IndexRoute, first, second, third 인 부분이 렌더링 되는곳 입니다.</p>\n<p>마지막으로 라우터의 히스토리는 browserHistory 에 저장해 둡니다. 그래야 브라우저에서 <code class=\"language-text\">뒤로가기</code>를 했을때 이전 페이지를 불러올 수 있기 때문이죠.</p>\n<h4>index.js</h4>\n<p>앱이 처음 시작하는 부분인 index.js 입니다.\nindex 에서 직접 라우팅을 구현하였습니다.\nthird 뒤의 <code class=\"language-text\">:id</code> 부분은 컴포넌트의 <code class=\"language-text\">this.props.params.id</code> 형태로 전달되어 컴포넌트 내에서 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport { Router, Route, IndexRoute, browserHistory } from &#39;react-router&#39;;\nimport App, { Home, First, Second, Third, Item } from &#39;./App.js&#39;;\n\nReactDOM.render(\n  &lt;Router history={browserHistory}&gt;\n    &lt;Route path=&quot;/&quot; component={App}&gt;\n      &lt;IndexRoute component={Home} /&gt;\n      &lt;Route path=&quot;first&quot; component={First} /&gt;\n      &lt;Route path=&quot;second&quot; component={Second} /&gt;\n      &lt;Route path=&quot;third/&quot; component={Third}&gt;\n        &lt;Route path=&quot;:id&quot; component={Item} /&gt;\n      &lt;/Route&gt;\n    &lt;/Route&gt;\n  &lt;/Router&gt;,\n  document.getElementById(&#39;root&#39;),\n);</code></pre></div>\n<h4>Header.js</h4>\n<p>헤더의 메뉴 부분입니다.\n버튼에 클릭했을때 라우터의 정보에 따라 컴포넌트를 바꿔줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { Component } from &#39;react&#39;;\nimport { Link } from &#39;react-router&#39;;\n\nclass Header extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;\n          &lt;li&gt;&lt;Link to={&#39;/&#39;}&gt;홈&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to={&#39;/first&#39;}&gt;첫번째&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to={&#39;/second&#39;}&gt;두번째&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to={&#39;/third&#39;}&gt;세번째&lt;/Link&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default Header;</code></pre></div>\n<h4>App.js</h4>\n<p>헤더를 제외한 모든 컴포넌트가 들어있는 App.js 파일입니다.</p>\n<p>App 컴포넌트는 최상위 패스인 <code class=\"language-text\">/</code>에서 렌더링 되는 부분인데요. <code class=\"language-text\">Header</code>와 같이 공통으로 사용하는 컴포넌트를 여기에 붙여줍니다.\n그러면, 어떤 url 로 이동하더라도 Header 는 계속 노출되겠지요.</p>\n<p>Third 부분이 v4 와 다른부분인데요. 컴포넌트 내에서 직접 라우팅 정보를 지정할 수 없기 때문에,\n우회하는 방법으로 <code class=\"language-text\">this.props.children</code> 컴포넌트가 있는지 여부에 따라서 어떻게 렌더링할지를 결정합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { Component } from &#39;react&#39;;\nimport Header from &#39;./Header.js&#39;;\nimport { Link } from &#39;react-router&#39;;\n\nclass App extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Header /&gt;\n        {this.props.children}\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class Home extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;홈 페이지&lt;/h1&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class First extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;1, 첫번째 페이지&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class Second extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;2, 두번째 페이지&lt;/h3&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class Third extends Component {\n  render() {\n    console.dir(this.props);\n    return (\n      &lt;div&gt;\n        &lt;Link to={&#39;/third/1&#39;} style={{ marginRight: &#39;5px&#39; }}&gt;\n          1번\n        &lt;/Link&gt;\n        &lt;Link to={&#39;/third/2&#39;}&gt;\n          2번\n        &lt;/Link&gt;\n        {this.props.children\n          ? this.props.children\n          : &lt;div&gt;\n              &lt;h3&gt;id를 선택해 주세요.&lt;/h3&gt;\n            &lt;/div&gt;}\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class Item extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;{this.props.params.id}&lt;/h3&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default App;</code></pre></div>\n<p>결과 화면입니다.</p>\n<p><img src=\"./asset_img%20result.png\" alt=\"result\"></p>\n<h2>v4 의 라우팅 코드</h2>\n<p>비교를 위해서 v3 와 동일한 화면으로 만들어 보겠습니다.</p>\n<h4>index.js</h4>\n<p>Router(BrowserRouter) 컴포넌트에 히스토리가 내장되어 있는걸로 보입니다.\nv3 에서는 history 객체를 별도로 가져와 Router 의 프로퍼티로 넣어줘야 했습니다만, v4 에서는 어떤 설정도 해줄 필요가 없습니다.\n또한, 라우터 컴포넌트 아래로 DOM 코드를 직접 넣어줄 수 있게 되었습니다.\n이게 의미하는게 뭐냐면, 어떤 코드에서든 <code class=\"language-text\">Route</code> 컴포넌트를 넣을 수 있다는 뜻입니다.\n즉, 라우트는 필요할때마다 동적으로 생성 가능하다는 것이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport { BrowserRouter as Router, Route } from &#39;react-router-dom&#39;;\nimport { Home, First, Second, Third } from &#39;./App.js&#39;;\nimport Header from &#39;./Header.js&#39;;\n\nReactDOM.render(\n  &lt;Router&gt;\n    &lt;div&gt;\n      &lt;Header /&gt;\n      &lt;Route exact path=&quot;/&quot; component={Home} /&gt;\n      &lt;Route path=&quot;/first&quot; component={First} /&gt;\n      &lt;Route path=&quot;/first&quot; component={First} /&gt;\n      &lt;Route path=&quot;/second&quot; component={Second} /&gt;\n      &lt;Route path=&quot;/third&quot; component={Third} /&gt;\n    &lt;/div&gt;\n  &lt;/Router&gt;,\n  document.getElementById(&#39;root&#39;),\n);</code></pre></div>\n<h4>Header.js</h4>\n<p>v3 와 거의 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { Component } from &#39;react&#39;;\nimport { Link } from &#39;react-router-dom&#39;;\n\nclass Header extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;\n          &lt;li&gt;&lt;Link to={&#39;/&#39;}&gt;홈&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to={&#39;/first&#39;}&gt;첫번째&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to={&#39;/second&#39;}&gt;두번째&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link to={&#39;/third&#39;}&gt;세번째&lt;/Link&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default Header;</code></pre></div>\n<h4>App.js</h4>\n<p>App 컴포넌트를 아예 만들지 않습니다. v3 에서 App 컴포넌트의 역할은 공통으로 사용하는 컴포넌트를 붙여주기 위함이었는데요.\nv4 에서는 라우트 컴포넌트 내에 직접 다른 컴포넌트를 붙여주면 되기 때문에 App 컴포넌트는 더이상 필요하지 않습니다.</p>\n<p>그리고 <code class=\"language-text\">Third</code> 컴포넌트는 위에서 동적라우팅 설명할때 잠깐 언급했던 것처럼\n컴포넌트 내에서 라우트 정보를 직접 넣어줄 수 있기 때문에 훨씬 명확한 코드를 작성할 수 있는것 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { Component } from &#39;react&#39;;\nimport Header from &#39;./Header.js&#39;;\nimport { Route, Link } from &#39;react-router-dom&#39;;\n\nexport class Home extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;홈 페이지&lt;/h1&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class First extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;1, 첫번째 페이지&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class Second extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;2, 두번째 페이지&lt;/h3&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport class Third extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;Link to={`${this.props.match.url}/1`} style={{ marginRight: &#39;5px&#39; }}&gt;\n          1번\n        &lt;/Link&gt;\n        &lt;Link to={`${this.props.match.url}/2`}&gt;\n          2번\n        &lt;/Link&gt;\n        &lt;Route\n          exact\n          path={this.props.match.url}\n          render={() =&gt; &lt;div&gt;&lt;h3&gt;id를 선택해 주세요.&lt;/h3&gt;&lt;/div&gt;}\n        /&gt;\n        &lt;Route path={`${this.props.match.url}/:id`} component={Item} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass Item extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h3&gt;{this.props.match.params.id}&lt;/h3&gt;\n      &lt;/div&gt;\n    );\n  }\n}</code></pre></div>\n<p>결과 화면입니다. 똑같습니다.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/result-fb1092558d8f5b50a2ba2af3b262bc43-ac1ec.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 67.60259179265658%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAABkUlEQVQ4y62S307CMBTG0XfxHbzwGdyF8VWU6B0kkGjiE5mYsCWEP0YYCNkfDKyjHdsAJSLJ1rNjW3ZhojcgX/LldP263zlpWujVjdN66+nisaafdzsdzbZtzXEcbTAYaK1WSzNNUzNfB5rZ62ky7/e7Yt0VtS++TZmftzvdi1qtdlKQcl+e9XhJsG876HkefqxW+Lle42azwcVijsT3kREPp1OKs1mIHmFIfYa+3J9RpJTiklFsNJvVLdC19a/1FzLGUkIICCgEQQBRFEEURiCAQC0LPNsBnzIYj33wJj5YYi+KQ4jjOF0EDNvt53sFDMOZ/h6ucbX85BlmWZqmGedc1SRJ1FoGHCDjeSYtBRwyAEhRyLLsLXCxnBvB6APndMVlgBnuInla/TcajbbAN2tiIKhQtsUdLaWArutugYT4Rt5NAXca7y+guFQjD3leDwc8+ITZfvoF1POGiTDs4SQH3imgeMANPICGw+GDApZKpctKpXJbLpevhK/38FW1Wr0pFotnhR86/qePJEQMWvgGW9KB3SlysaIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"result\"\n        title=\"\"\n        src=\"/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fb8a0.png\"\n        srcset=\"/static/result-fb1092558d8f5b50a2ba2af3b262bc43-1a291.png 148w,\n/static/result-fb1092558d8f5b50a2ba2af3b262bc43-2bc4a.png 295w,\n/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fb8a0.png 590w,\n/static/result-fb1092558d8f5b50a2ba2af3b262bc43-526de.png 885w,\n/static/result-fb1092558d8f5b50a2ba2af3b262bc43-fa2eb.png 1180w,\n/static/result-fb1092558d8f5b50a2ba2af3b262bc43-08f6a.png 1770w,\n/static/result-fb1092558d8f5b50a2ba2af3b262bc43-ac1ec.png 1852w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3>결론</h3>\n<blockquote>\n<p>아직 깊이 살펴보지 못해서 어떤 장점이 더 있는지는 모르겠습니다만,\n어떻게 보면 v4 가 v3 에 비해서 산만해 보일수도 있습니다.\n한곳에서 모든 라우팅 정보를 볼 수 있는게 좋다고 생각할 수도 있으니까요.\n하지만, 리액트의 철학과 어울리는 라우팅 방식은 v4 의 동적 라우팅이 아닐까 생각이 듭니다.</p>\n</blockquote>","frontmatter":{"title":"[react] react-router(리액트 라우터) v3 VS v4","date":"June 22, 2017"}}},"pageContext":{"slug":"/2017/06/22/static-routing-vs-dynamic-routing/","previous":{"fields":{"slug":"/2017/06/20/create-react-app/"},"frontmatter":{"title":"[ReactJs] create-react-app으로 react 시작하기"}},"next":{"fields":{"slug":"/2017/06/26/presentaional-component-container-component/"},"frontmatter":{"title":"[번역] 프레젠테이션 컴포넌트와 컨테이너 컴포넌트"}}}}